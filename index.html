<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bitven - Forca</title>
  <link rel="icon" type="image/ico" href="favicon.ico">
  <script src="/_sdk/element_sdk.js"></script>
  <script src="/_sdk/data_sdk.js"></script><!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100%;
      color: #ffffff;
    }

    * {
      box-sizing: border-box;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header */
    .header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
    }

    .logo {
      font-size: 28px;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      color: #ffffff;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .btn-primary:hover {
      background: linear-gradient(135deg, #5568d3 0%, #65408b 100%);
    }

    .btn-danger {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    /* Login Screen */
    .login-screen {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100%;
      padding: 20px;
    }

    .login-card {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      max-width: 400px;
      width: 100%;
    }

    .login-card h1 {
      font-size: 36px;
      margin-bottom: 10px;
    }

    .login-card p {
      margin-bottom: 30px;
      opacity: 0.9;
    }

    /* Dashboard Grid */
    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      padding: 25px;
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .card h2 {
      font-size: 18px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .balance-display {
      font-size: 42px;
      font-weight: bold;
      margin: 20px 0;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .price-display {
      font-size: 32px;
      font-weight: bold;
      color: #4ade80;
      margin: 15px 0;
    }

    .price-change {
      font-size: 14px;
      padding: 5px 10px;
      border-radius: 5px;
      display: inline-block;
    }

    .price-up {
      background: rgba(74, 222, 128, 0.2);
      color: #4ade80;
    }

    .price-down {
      background: rgba(248, 113, 113, 0.2);
      color: #f87171;
    }

    /* Chart */
    .chart-container {
      height: 200px;
      position: relative;
      margin-top: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 15px;
      overflow: hidden;
    }

    .chart-svg {
      width: 100%;
      height: 100%;
    }

    .chart-line {
      fill: none;
      stroke: #4ade80;
      stroke-width: 2;
      filter: drop-shadow(0 0 4px rgba(74, 222, 128, 0.5));
    }

    .chart-area {
      fill: url(#chartGradient);
      opacity: 0.3;
    }

    .chart-grid {
      stroke: rgba(255, 255, 255, 0.1);
      stroke-width: 1;
    }

    .chart-label {
      fill: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      font-family: inherit;
    }

    /* Transfer Form */
    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 500;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: #ffffff;
      font-size: 14px;
    }

    .form-group input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    /* Leaderboard */
    .leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .leaderboard-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
    }

    .leaderboard-item:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(5px);
    }

    .rank {
      font-size: 24px;
      font-weight: bold;
      width: 40px;
      text-align: center;
    }

    .rank-1 { color: #ffd700; }
    .rank-2 { color: #c0c0c0; }
    .rank-3 { color: #cd7f32; }

    /* Transactions */
    .transaction-list {
      max-height: 400px;
      overflow-y: auto;
    }

    .transaction-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .transaction-type {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }

    .type-send {
      background: rgba(248, 113, 113, 0.2);
      color: #f87171;
    }

    .type-receive {
      background: rgba(74, 222, 128, 0.2);
      color: #4ade80;
    }

    /* Admin Panel */
    .admin-panel {
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 215, 0, 0.5);
      padding: 25px;
      border-radius: 15px;
      margin-bottom: 30px;
    }

    .admin-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tab {
      padding: 10px 20px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 8px;
      color: #ffffff;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .tab.active {
      background: rgba(255, 255, 255, 0.3);
      font-weight: bold;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Loading */
    .loading {
      text-align: center;
      padding: 40px;
      font-size: 18px;
    }

    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #ffffff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Notifications */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      color: #333;
      padding: 15px 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      animation: slideIn 0.3s ease;
      max-width: 300px;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .notification.success {
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      color: #ffffff;
    }

    .notification.error {
      background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
      color: #ffffff;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header {
        flex-direction: column;
        text-align: center;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }

      .balance-display {
        font-size: 32px;
      }

      .price-display {
        font-size: 24px;
      }
    }

    /* Streak Badge */
    .streak-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      background: rgba(255, 215, 0, 0.2);
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      color: #ffd700;
    }

    /* Mission Card */
    .mission-card {
      background: rgba(255, 255, 255, 0.05);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 10px;
      border-left: 4px solid #4ade80;
    }

    .mission-card h3 {
      font-size: 16px;
      margin-bottom: 8px;
    }

    .mission-card p {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 10px;
    }

    .progress-bar {
      background: rgba(255, 255, 255, 0.1);
      height: 8px;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .progress-fill {
      background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);
      height: 100%;
      transition: width 0.3s ease;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div id="app">
   <div class="loading">
    <div class="spinner"></div>
    <p>Loading Bitven...</p>
   </div>
  </div>
  <script type="module">
    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyDWSebqVunmSzmw168fDZE_ePqoJ-_jsig",
      authDomain: "bitven-6d42c.firebaseapp.com",
      projectId: "bitven-6d42c",
      storageBucket: "bitven-6d42c.firebasestorage.app",
      messagingSenderId: "511584242303",
      appId: "1:511584242303:web:bdfeac7801c4d17b254d4a"
    };

    /*
    ========================================
    üîí FIRESTORE SECURITY RULES FOR BITVEN
    ========================================
    
    üìã COPY THESE RULES TO FIREBASE CONSOLE:
    1. Go to Firebase Console ‚Üí Firestore Database ‚Üí Rules tab
    2. Copy everything from "rules_version = '2';" to the final closing "}"
    3. Paste and publish the rules
    
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {
        
        // Helper functions for validation and permissions
        function isAuthenticated() {
          return request.auth != null;
        }
        
        function isOwner(userId) {
          return request.auth.uid == userId;
        }
        
        function isAdmin() {
          return isAuthenticated() && 
                 get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
        }
        
        function isValidEmail(email) {
          return email is string && email.matches('.*@.*\\..*');
        }
        
        function isValidBalance(balance) {
          return balance is number && balance >= 0 && balance <= 1000000;
        }
        
        function isValidAmount(amount) {
          return amount is number && amount > 0 && amount <= 10000;
        }
        
        function isValidPrice(price) {
          return price is number && price > 0 && price <= 1000000;
        }
        
        // Users collection - User profiles and balances
        match /users/{userId} {
          // Read: Users can read their own profile + others for transfers/leaderboard
          allow read: if isAuthenticated();
          
          // Create: Only during initial signup with proper structure
          allow create: if isOwner(userId) && 
                           isValidUserData(request.resource.data) &&
                           request.resource.data.balance_bvn == 0 &&
                           request.resource.data.net_worth == 0 &&
                           request.resource.data.role in ['user', 'admin'] &&
                           request.resource.data.frozen == false;
          
          // Update: Users can update their own profile (limited fields)
          // Admins can update any user (including balance changes)
          allow update: if (isOwner(userId) && isValidUserUpdate(request.resource.data)) ||
                           (isAdmin() && isValidAdminUserUpdate(request.resource.data));
          
          // Delete: Only admins can delete users
          allow delete: if isAdmin();
          
          function isValidUserData(data) {
            return data.keys().hasAll(['displayName', 'email', 'balance_bvn', 'net_worth', 'avatar', 'frozen', 'role', 'streak']) &&
                   data.displayName is string &&
                   isValidEmail(data.email) &&
                   isValidBalance(data.balance_bvn) &&
                   data.net_worth is number &&
                   data.avatar is string &&
                   data.frozen is bool &&
                   data.role in ['user', 'admin'] &&
                   data.streak is number && data.streak >= 0;
          }
          
          function isValidUserUpdate(data) {
            let allowedFields = ['displayName', 'avatar', 'lastLogin', 'streak'];
            return data.diff(resource.data).affectedKeys().hasOnly(allowedFields) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['displayName']) || data.displayName is string) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['avatar']) || data.avatar is string);
          }
          
          function isValidAdminUserUpdate(data) {
            let allowedFields = ['displayName', 'avatar', 'balance_bvn', 'net_worth', 'frozen', 'role', 'lastLogin', 'streak'];
            return data.diff(resource.data).affectedKeys().hasOnly(allowedFields) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['balance_bvn']) || isValidBalance(data.balance_bvn)) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['net_worth']) || data.net_worth is number) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['frozen']) || data.frozen is bool) &&
                   (!data.diff(resource.data).affectedKeys().hasAny(['role']) || data.role in ['user', 'admin']);
          }
        }
        
        // Ledger collection - Immutable transaction records
        match /ledger/{transactionId} {
          // Read: Users can read transactions they're involved in
          // Admins can read all transactions
          allow read: if isAuthenticated() && 
                         (resource.data.from == request.auth.uid || 
                          resource.data.to == request.auth.uid || 
                          isAdmin());
          
          // Create: Only authenticated users can create valid transactions
          // Additional validation should be done in client-side transaction logic
          allow create: if isAuthenticated() && 
                           isValidTransaction(request.resource.data) &&
                           (request.resource.data.from == request.auth.uid || 
                            request.resource.data.from == 'system' ||
                            isAdmin());
          
          // Update/Delete: Transactions are immutable (no updates or deletes allowed)
          allow update, delete: if false;
          
          function isValidTransaction(data) {
            return data.keys().hasAll(['txId', 'type', 'from', 'to', 'amount', 'timestamp']) &&
                   data.txId is string &&
                   data.type in ['transfer', 'mint', 'burn', 'streak_reward'] &&
                   (data.from is string || data.from == 'system') &&
                   (data.to is string || data.to == 'system') &&
                   isValidAmount(data.amount) &&
                   data.timestamp is timestamp &&
                   data.from != data.to;
          }
        }
        
        // Price feed - Current BVN price
        match /price_feed/current {
          // Read: Anyone authenticated can read current price
          allow read: if isAuthenticated();
          
          // Write: Only admins can update price
          allow write: if isAdmin() && 
                          isValidPrice(request.resource.data.price_ngn) &&
                          request.resource.data.updatedBy == request.auth.uid &&
                          request.resource.data.timestamp is timestamp;
        }
        
        // Price feed history - Historical price data
        match /price_feed_history/{historyId} {
          // Read: Anyone authenticated can read price history
          allow read: if isAuthenticated();
          
          // Create: Only admins can create price history entries
          allow create: if isAdmin() && 
                           isValidPrice(request.resource.data.price_ngn) &&
                           request.resource.data.updatedBy == request.auth.uid &&
                           request.resource.data.timestamp is timestamp;
          
          // Update/Delete: Price history is immutable
          allow update, delete: if false;
        }
        
        // Admin audit log - Track admin actions
        match /admin_audit/{auditId} {
          // Read: Only admins can read audit logs
          allow read: if isAdmin();
          
          // Create: Only admins can create audit entries for their own actions
          allow create: if isAdmin() && 
                           request.resource.data.adminId == request.auth.uid &&
                           request.resource.data.action is string &&
                           request.resource.data.timestamp is timestamp;
          
          // Update/Delete: Audit logs are immutable
          allow update, delete: if false;
        }
        
        // System configuration (optional - for app settings)
        match /system_config/{configId} {
          // Read: Anyone authenticated can read system config
          allow read: if isAuthenticated();
          
          // Write: Only admins can modify system configuration
          allow write: if isAdmin();
        }
        
        // User sessions (optional - for tracking active sessions)
        match /user_sessions/{sessionId} {
          // Read/Write: Users can manage their own sessions
          allow read, write: if isAuthenticated() && 
                                resource.data.userId == request.auth.uid;
          
          // Admin read: Admins can read all sessions for monitoring
          allow read: if isAdmin();
        }
        
        // Notifications (optional - for user notifications)
        match /notifications/{notificationId} {
          // Read: Users can read their own notifications
          allow read: if isAuthenticated() && 
                         resource.data.userId == request.auth.uid;
          
          // Create: System or admins can create notifications
          allow create: if isAdmin() || 
                           (isAuthenticated() && request.resource.data.type == 'system');
          
          // Update: Users can mark their notifications as read
          allow update: if isAuthenticated() && 
                           resource.data.userId == request.auth.uid &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
          
          // Delete: Users can delete their own notifications
          allow delete: if isAuthenticated() && 
                           resource.data.userId == request.auth.uid;
        }
        
        // Deny all other collections by default
        match /{document=**} {
          allow read, write: if false;
        }
      }
    }
    
    ========================================
    ADDITIONAL SECURITY RECOMMENDATIONS:
    ========================================
    
    1. AUTHENTICATION RULES:
       - Enable Google Sign-In only (disable anonymous auth)
       - Set up proper OAuth consent screen
       - Limit authorized domains to your production domain
    
    2. FIRESTORE SETTINGS:
       - Enable App Check for additional security
       - Set up proper indexes for query performance
       - Configure backup schedules for data protection
    
    3. ADMIN ACCOUNT SECURITY:
       - Use strong, unique passwords for admin accounts
       - Enable 2FA on all admin Google accounts
       - Regularly audit admin permissions
       - Consider using service accounts for automated tasks
    
    4. MONITORING & ALERTS:
       - Set up Firebase monitoring for unusual activity
       - Configure alerts for failed authentication attempts
       - Monitor transaction volumes and patterns
       - Set up budget alerts to prevent unexpected costs
    
    5. DATA VALIDATION:
       - All monetary amounts are validated (positive, reasonable limits)
       - Email addresses are properly formatted
       - User roles are restricted to valid values
       - Transaction types are limited to allowed operations
    
    6. RATE LIMITING:
       - Consider implementing client-side rate limiting
       - Use Firebase App Check to prevent abuse
       - Monitor for suspicious transaction patterns
    
    ========================================
    */

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Demo State Management
    const state = {
      currentUser: null,
      users: [],
      transactions: [],
      currentPrice: 1500,
      priceHistory: [],
      isAdmin: false,
      config: {
        app_title: "Bitven",
        welcome_message: "Welcome to Bitven Crypto Simulator"
      }
    };

    // Initialize Data SDK
    const dataHandler = {
      onDataChanged(data) {
        state.transactions = data;
        if (state.currentUser) {
          renderApp();
        }
      }
    };

    // Initialize Element SDK
    const defaultConfig = {
      app_title: "Bitven",
      welcome_message: "Welcome to Bitven Crypto Simulator",
      primary_color: "#667eea",
      secondary_color: "#764ba2",
      text_color: "#ffffff",
      surface_color: "rgba(255, 255, 255, 0.1)",
      accent_color: "#4ade80"
    };

    async function onConfigChange(config) {
      state.config = config;
      document.documentElement.style.setProperty('--primary-color', config.primary_color || defaultConfig.primary_color);
      document.documentElement.style.setProperty('--secondary-color', config.secondary_color || defaultConfig.secondary_color);
      document.documentElement.style.setProperty('--text-color', config.text_color || defaultConfig.text_color);
      
      const titleElements = document.querySelectorAll('.app-title');
      titleElements.forEach(el => {
        el.textContent = config.app_title || defaultConfig.app_title;
      });

      const welcomeElements = document.querySelectorAll('.welcome-message');
      welcomeElements.forEach(el => {
        el.textContent = config.welcome_message || defaultConfig.welcome_message;
      });
    }

    // Real Firebase Google Authentication
    async function googleLogin() {
      try {
        const provider = new firebase.auth.GoogleAuthProvider();
        const result = await auth.signInWithPopup(provider);
        const user = result.user;
        
        // Check if user exists in Firestore
        const userDoc = await db.collection('users').doc(user.uid).get();
        
        if (!userDoc.exists) {
          // Create new user document
          await db.collection('users').doc(user.uid).set({
            displayName: user.displayName,
            email: user.email,
            balance_bvn: 0,
            net_worth: 0,
            avatar: user.photoURL || 'üë§',
            frozen: false,
            role: user.email === 'vesni277@gmail.com' ? 'admin' : 'user',
            streak: 0,
            lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });
        }
        
        // Update user data
        const userData = userDoc.exists ? userDoc.data() : {
          displayName: user.displayName,
          email: user.email,
          balance_bvn: 0,
          net_worth: 0,
          avatar: user.photoURL || 'üë§',
          frozen: false,
          role: user.email === 'vesni277@gmail.com' ? 'admin' : 'user',
          streak: 0
        };
        
        state.currentUser = {
          uid: user.uid,
          ...userData
        };
        
        state.isAdmin = userData.role === 'admin';
        
        // Check streak and award bonus
        await checkAndAwardStreak();
        
        showNotification('Login successful!', 'success');
        renderApp();
        
      } catch (error) {
        console.error('Login error:', error);
        showNotification('Login failed: ' + error.message, 'error');
      }
    }

    async function checkAndAwardStreak() {
      const user = state.currentUser;
      const userRef = db.collection('users').doc(user.uid);
      
      try {
        const userDoc = await userRef.get();
        const userData = userDoc.data();
        const lastLogin = userData.lastLogin ? userData.lastLogin.toDate() : new Date(0);
        const now = new Date();
        const daysDiff = Math.floor((now - lastLogin) / (1000 * 60 * 60 * 24));

        let newStreak = userData.streak || 0;
        let newBalance = userData.balance_bvn || 0;

        if (daysDiff === 1) {
          newStreak += 1;
          if (newStreak >= 7) {
            newBalance += 0.001;
            showNotification('üéâ 7-day streak! You earned 0.001 BVN!', 'success');
            
            // Log the streak reward transaction
            await db.collection('ledger').add({
              txId: 'streak_' + Date.now(),
              type: 'streak_reward',
              from: 'system',
              to: user.uid,
              amount: 0.001,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
              balancesAfter: { [user.uid]: newBalance }
            });
            
            newStreak = 0;
          }
        } else if (daysDiff > 1) {
          newStreak = 1;
        }

        // Update user document
        await userRef.update({
          streak: newStreak,
          balance_bvn: newBalance,
          lastLogin: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Update local state
        user.streak = newStreak;
        user.balance_bvn = newBalance;
        
      } catch (error) {
        console.error('Error updating streak:', error);
      }
    }

    async function logout() {
      try {
        await auth.signOut();
        state.currentUser = null;
        state.isAdmin = false;
        state.transactions = [];
        showNotification('Logged out successfully', 'success');
        renderApp();
      } catch (error) {
        console.error('Logout error:', error);
        showNotification('Logout failed', 'error');
      }
    }

    // Price Management
    async function updatePrice(newPrice) {
      if (!state.isAdmin) {
        showNotification('Only admins can update prices', 'error');
        return;
      }

      try {
        const batch = db.batch();
        
        // Update current price
        const priceRef = db.collection('price_feed').doc('current');
        batch.set(priceRef, {
          price_ngn: newPrice,
          updatedBy: state.currentUser.uid,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Add to price history
        const historyRef = db.collection('price_feed_history').doc();
        batch.set(historyRef, {
          price_ngn: newPrice,
          updatedBy: state.currentUser.uid,
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Log admin action
        const auditRef = db.collection('admin_audit').doc();
        batch.set(auditRef, {
          action: 'price_update',
          adminId: state.currentUser.uid,
          details: {
            oldPrice: state.currentPrice,
            newPrice: newPrice
          },
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });

        await batch.commit();

        // Update local state
        state.currentPrice = newPrice;
        
        // Recalculate net worths for all users
        await recalculateAllNetWorths(newPrice);

        showNotification(`Price updated to ‚Ç¶${newPrice.toLocaleString()}`, 'success');
        renderApp();
        
      } catch (error) {
        console.error('Error updating price:', error);
        showNotification('Failed to update price', 'error');
      }
    }

    async function recalculateAllNetWorths(currentPrice) {
      try {
        const usersSnapshot = await db.collection('users').get();
        const batch = db.batch();

        usersSnapshot.forEach(doc => {
          const userData = doc.data();
          const newNetWorth = userData.balance_bvn * currentPrice;
          batch.update(doc.ref, { net_worth: newNetWorth });
        });

        await batch.commit();
      } catch (error) {
        console.error('Error recalculating net worths:', error);
      }
    }

    // Receipt Generation System
    function generateReceipt(transactionData, status = 'success') {
      const receiptId = 'RCP_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      const timestamp = new Date().toLocaleString();
      
      const receiptHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>Bitven Transaction Receipt</title>
          <style>
            body { 
              font-family: 'Courier New', monospace; 
              max-width: 400px; 
              margin: 20px auto; 
              padding: 20px; 
              background: #f5f5f5;
              color: #333;
            }
            .receipt { 
              background: white; 
              padding: 30px; 
              border-radius: 10px; 
              box-shadow: 0 4px 20px rgba(0,0,0,0.1);
              border: 2px dashed #ccc;
            }
            .header { 
              text-align: center; 
              border-bottom: 2px solid #333; 
              padding-bottom: 15px; 
              margin-bottom: 20px; 
            }
            .logo { 
              font-size: 24px; 
              font-weight: bold; 
              color: #667eea; 
            }
            .status { 
              padding: 10px; 
              border-radius: 5px; 
              text-align: center; 
              font-weight: bold; 
              margin: 15px 0; 
            }
            .success { 
              background: #d4edda; 
              color: #155724; 
              border: 1px solid #c3e6cb; 
            }
            .failed { 
              background: #f8d7da; 
              color: #721c24; 
              border: 1px solid #f5c6cb; 
            }
            .row { 
              display: flex; 
              justify-content: space-between; 
              margin: 8px 0; 
              padding: 5px 0;
            }
            .row.total { 
              border-top: 2px solid #333; 
              font-weight: bold; 
              font-size: 18px; 
              margin-top: 15px;
              padding-top: 10px;
            }
            .footer { 
              text-align: center; 
              margin-top: 20px; 
              font-size: 12px; 
              color: #666; 
              border-top: 1px solid #ccc; 
              padding-top: 15px;
            }
            @media print {
              body { margin: 0; background: white; }
              .receipt { box-shadow: none; border: 1px solid #000; }
            }
          </style>
        </head>
        <body>
          <div class="receipt">
            <div class="header">
              <div class="logo">ü™ô BITVEN</div>
              <div>Transaction Receipt</div>
            </div>
            
            <div class="status ${status}">
              ${status === 'success' ? '‚úÖ TRANSACTION SUCCESSFUL' : '‚ùå TRANSACTION FAILED'}
            </div>
            
            <div class="row">
              <span>Receipt ID:</span>
              <span>${receiptId}</span>
            </div>
            
            <div class="row">
              <span>Transaction ID:</span>
              <span>${transactionData.txId || 'N/A'}</span>
            </div>
            
            <div class="row">
              <span>Date & Time:</span>
              <span>${timestamp}</span>
            </div>
            
            <div class="row">
              <span>Type:</span>
              <span>${transactionData.type?.toUpperCase() || 'TRANSFER'}</span>
            </div>
            
            <div class="row">
              <span>From:</span>
              <span>${transactionData.fromName || transactionData.from || 'System'}</span>
            </div>
            
            <div class="row">
              <span>To:</span>
              <span>${transactionData.toName || transactionData.to || 'System'}</span>
            </div>
            
            <div class="row">
              <span>BVN Rate:</span>
              <span>‚Ç¶${state.currentPrice.toLocaleString()}</span>
            </div>
            
            <div class="row total">
              <span>Amount:</span>
              <span>${transactionData.amount} BVN</span>
            </div>
            
            <div class="row">
              <span>Value (NGN):</span>
              <span>‚Ç¶${(transactionData.amount * state.currentPrice).toLocaleString()}</span>
            </div>
            
            ${status === 'success' ? `
              <div class="row">
                <span>New Balance:</span>
                <span>${transactionData.newBalance?.toFixed(4) || 'N/A'} BVN</span>
              </div>
            ` : `
              <div class="row">
                <span>Reason:</span>
                <span>${transactionData.error || 'Transaction failed'}</span>
              </div>
            `}
            
            <div class="footer">
              <div>Bitven Currency System</div>
              <div>Secure ‚Ä¢ Fast ‚Ä¢ Reliable</div>
              <div style="margin-top: 10px; font-size: 10px;">
                This is an automatically generated receipt.<br>
                Keep this for your records.
              </div>
            </div>
          </div>
        </body>
        </html>
      `;
      
      return { receiptHTML, receiptId };
    }

    function downloadReceipt(receiptHTML, receiptId) {
      const blob = new Blob([receiptHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Bitven_Receipt_${receiptId}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function showReceiptModal(receiptHTML, receiptId, status) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
      `;
      
      modal.innerHTML = `
        <div style="
          background: white;
          border-radius: 15px;
          max-width: 500px;
          width: 100%;
          max-height: 90vh;
          overflow-y: auto;
          position: relative;
        ">
          <div style="
            position: sticky;
            top: 0;
            background: white;
            padding: 20px;
            border-bottom: 1px solid #eee;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
          ">
            <h3 style="margin: 0; color: #333;">Transaction Receipt</h3>
            <button onclick="this.closest('.receipt-modal').remove()" style="
              background: none;
              border: none;
              font-size: 24px;
              cursor: pointer;
              color: #666;
            ">√ó</button>
          </div>
          
          <div style="padding: 0 20px;">
            <iframe srcdoc="${receiptHTML.replace(/"/g, '&quot;')}" style="
              width: 100%;
              height: 400px;
              border: none;
              border-radius: 10px;
            "></iframe>
          </div>
          
          <div style="
            padding: 20px;
            border-top: 1px solid #eee;
            display: flex;
            gap: 10px;
            justify-content: center;
          ">
            <button onclick="downloadReceiptFromModal('${receiptId}')" style="
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
            ">üì• Download Receipt</button>
            
            <button onclick="printReceiptFromModal()" style="
              background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 8px;
              cursor: pointer;
              font-weight: 500;
            ">üñ®Ô∏è Print Receipt</button>
          </div>
        </div>
      `;
      
      modal.className = 'receipt-modal';
      document.body.appendChild(modal);
      
      // Store receipt data for modal functions
      window.currentReceiptHTML = receiptHTML;
      window.currentReceiptId = receiptId;
    }

    window.downloadReceiptFromModal = function(receiptId) {
      downloadReceipt(window.currentReceiptHTML, receiptId);
      showNotification('Receipt downloaded successfully!', 'success');
    };

    window.printReceiptFromModal = function() {
      const printWindow = window.open('', '_blank');
      printWindow.document.write(window.currentReceiptHTML);
      printWindow.document.close();
      printWindow.print();
    };

    // Transfer BVN with Receipt Generation
    async function transferBVN(recipientEmail, amount) {
      if (!state.currentUser) return;

      amount = parseFloat(amount);
      
      if (amount <= 0) {
        showNotification('Amount must be greater than 0', 'error');
        const failedTxData = {
          txId: 'FAILED_' + Date.now(),
          type: 'transfer',
          from: state.currentUser.displayName,
          to: recipientEmail,
          amount: amount,
          error: 'Invalid amount'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }

      if (amount > state.currentUser.balance_bvn && !state.isAdmin) {
        showNotification('Insufficient balance', 'error');
        const failedTxData = {
          txId: 'FAILED_' + Date.now(),
          type: 'transfer',
          from: state.currentUser.displayName,
          to: recipientEmail,
          amount: amount,
          error: 'Insufficient balance'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }

      if (recipientEmail === state.currentUser.email) {
        showNotification('Cannot transfer to yourself', 'error');
        const failedTxData = {
          txId: 'FAILED_' + Date.now(),
          type: 'transfer',
          from: state.currentUser.displayName,
          to: recipientEmail,
          amount: amount,
          error: 'Cannot transfer to yourself'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }

      try {
        // Find recipient user
        const recipientQuery = await db.collection('users').where('email', '==', recipientEmail).get();
        
        if (recipientQuery.empty) {
          showNotification('Recipient not found', 'error');
          const failedTxData = {
            txId: 'FAILED_' + Date.now(),
            type: 'transfer',
            from: state.currentUser.displayName,
            to: recipientEmail,
            amount: amount,
            error: 'Recipient not found'
          };
          const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
          showReceiptModal(receiptHTML, receiptId, 'failed');
          return;
        }

        const recipientDoc = recipientQuery.docs[0];
        const recipientData = recipientDoc.data();

        if (recipientData.frozen) {
          showNotification('Recipient account is frozen', 'error');
          const failedTxData = {
            txId: 'FAILED_' + Date.now(),
            type: 'transfer',
            from: state.currentUser.displayName,
            to: recipientData.displayName,
            amount: amount,
            error: 'Recipient account is frozen'
          };
          const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
          showReceiptModal(receiptHTML, receiptId, 'failed');
          return;
        }

        let transactionId = 'TX_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        let newSenderBalance;

        // Use Firestore transaction for atomic transfer
        await db.runTransaction(async (transaction) => {
          const senderRef = db.collection('users').doc(state.currentUser.uid);
          const recipientRef = recipientDoc.ref;

          // Get fresh data
          const senderDoc = await transaction.get(senderRef);
          const recipientDocFresh = await transaction.get(recipientRef);

          const senderData = senderDoc.data();
          const recipientDataFresh = recipientDocFresh.data();

          // Validate sender balance again (admins have unlimited BVN)
          if (senderData.balance_bvn < amount && !state.isAdmin) {
            throw new Error('Insufficient balance');
          }

          // For admins, allow unlimited transfers by minting if needed
          if (state.isAdmin && senderData.balance_bvn < amount) {
            newSenderBalance = amount; // Set balance to at least the transfer amount
          } else {
            newSenderBalance = senderData.balance_bvn - amount;
          }
          
          const newRecipientBalance = recipientDataFresh.balance_bvn + amount;

          // Update balances
          transaction.update(senderRef, { 
            balance_bvn: newSenderBalance,
            net_worth: newSenderBalance * state.currentPrice
          });
          transaction.update(recipientRef, { 
            balance_bvn: newRecipientBalance,
            net_worth: newRecipientBalance * state.currentPrice
          });

          // Create ledger entry
          const ledgerRef = db.collection('ledger').doc();
          transaction.set(ledgerRef, {
            txId: transactionId,
            type: 'transfer',
            from: state.currentUser.uid,
            to: recipientDoc.id,
            amount: amount,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            balancesAfter: {
              [state.currentUser.uid]: newSenderBalance,
              [recipientDoc.id]: newRecipientBalance
            },
            receiptGenerated: true
          });

          // Update local state
          state.currentUser.balance_bvn = newSenderBalance;
        });

        showNotification(`Successfully sent ${amount} BVN to ${recipientEmail}`, 'success');
        
        // Generate success receipt
        const successTxData = {
          txId: transactionId,
          type: 'transfer',
          fromName: state.currentUser.displayName,
          toName: recipientData.displayName,
          from: state.currentUser.displayName,
          to: recipientData.displayName,
          amount: amount,
          newBalance: newSenderBalance
        };
        const { receiptHTML, receiptId } = generateReceipt(successTxData, 'success');
        showReceiptModal(receiptHTML, receiptId, 'success');
        
        renderApp();
        
      } catch (error) {
        console.error('Transfer error:', error);
        showNotification('Transfer failed: ' + error.message, 'error');
        
        // Generate failure receipt
        const failedTxData = {
          txId: 'FAILED_' + Date.now(),
          type: 'transfer',
          from: state.currentUser.displayName,
          to: recipientEmail,
          amount: amount,
          error: error.message
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
      }
    }

    // Admin Functions with Receipt Generation
    async function mintBVN(amount) {
      if (!state.isAdmin) return;
      
      amount = parseFloat(amount);
      const maxDaily = 5000;
      
      if (amount <= 0) {
        showNotification('Amount must be greater than 0', 'error');
        const failedTxData = {
          txId: 'FAILED_MINT_' + Date.now(),
          type: 'mint',
          from: 'System',
          to: state.currentUser.displayName,
          amount: amount,
          error: 'Invalid amount'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }
      
      if (amount > maxDaily) {
        showNotification(`Cannot mint more than ${maxDaily} BVN per day`, 'error');
        const failedTxData = {
          txId: 'FAILED_MINT_' + Date.now(),
          type: 'mint',
          from: 'System',
          to: state.currentUser.displayName,
          amount: amount,
          error: `Exceeds daily limit of ${maxDaily} BVN`
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }

      try {
        const userRef = db.collection('users').doc(state.currentUser.uid);
        const newBalance = state.currentUser.balance_bvn + amount;
        const transactionId = 'MINT_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        await db.runTransaction(async (transaction) => {
          // Update user balance
          transaction.update(userRef, { 
            balance_bvn: newBalance,
            net_worth: newBalance * state.currentPrice
          });

          // Create ledger entry
          const ledgerRef = db.collection('ledger').doc();
          transaction.set(ledgerRef, {
            txId: transactionId,
            type: 'mint',
            from: 'system',
            to: state.currentUser.uid,
            amount: amount,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            balancesAfter: { [state.currentUser.uid]: newBalance },
            receiptGenerated: true
          });

          // Log admin action
          const auditRef = db.collection('admin_audit').doc();
          transaction.set(auditRef, {
            action: 'mint_bvn',
            adminId: state.currentUser.uid,
            details: { amount: amount, transactionId: transactionId },
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        });

        state.currentUser.balance_bvn = newBalance;
        showNotification(`Minted ${amount} BVN`, 'success');
        
        // Generate success receipt
        const successTxData = {
          txId: transactionId,
          type: 'mint',
          fromName: 'System (Admin)',
          toName: state.currentUser.displayName,
          from: 'System (Admin)',
          to: state.currentUser.displayName,
          amount: amount,
          newBalance: newBalance
        };
        const { receiptHTML, receiptId } = generateReceipt(successTxData, 'success');
        showReceiptModal(receiptHTML, receiptId, 'success');
        
        renderApp();
        
      } catch (error) {
        console.error('Mint error:', error);
        showNotification('Failed to mint BVN', 'error');
        
        // Generate failure receipt
        const failedTxData = {
          txId: 'FAILED_MINT_' + Date.now(),
          type: 'mint',
          from: 'System (Admin)',
          to: state.currentUser.displayName,
          amount: amount,
          error: error.message
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
      }
    }

    async function burnBVN(amount) {
      if (!state.isAdmin) return;
      
      amount = parseFloat(amount);
      
      if (amount <= 0) {
        showNotification('Amount must be greater than 0', 'error');
        const failedTxData = {
          txId: 'FAILED_BURN_' + Date.now(),
          type: 'burn',
          from: state.currentUser.displayName,
          to: 'System (Admin)',
          amount: amount,
          error: 'Invalid amount'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }
      
      if (amount > state.currentUser.balance_bvn) {
        showNotification('Insufficient balance to burn', 'error');
        const failedTxData = {
          txId: 'FAILED_BURN_' + Date.now(),
          type: 'burn',
          from: state.currentUser.displayName,
          to: 'System (Admin)',
          amount: amount,
          error: 'Insufficient balance'
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
        return;
      }

      try {
        const userRef = db.collection('users').doc(state.currentUser.uid);
        const newBalance = state.currentUser.balance_bvn - amount;
        const transactionId = 'BURN_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        await db.runTransaction(async (transaction) => {
          // Update user balance
          transaction.update(userRef, { 
            balance_bvn: newBalance,
            net_worth: newBalance * state.currentPrice
          });

          // Create ledger entry
          const ledgerRef = db.collection('ledger').doc();
          transaction.set(ledgerRef, {
            txId: transactionId,
            type: 'burn',
            from: state.currentUser.uid,
            to: 'system',
            amount: amount,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            balancesAfter: { [state.currentUser.uid]: newBalance },
            receiptGenerated: true
          });

          // Log admin action
          const auditRef = db.collection('admin_audit').doc();
          transaction.set(auditRef, {
            action: 'burn_bvn',
            adminId: state.currentUser.uid,
            details: { amount: amount, transactionId: transactionId },
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
        });

        state.currentUser.balance_bvn = newBalance;
        showNotification(`Burned ${amount} BVN`, 'success');
        
        // Generate success receipt
        const successTxData = {
          txId: transactionId,
          type: 'burn',
          fromName: state.currentUser.displayName,
          toName: 'System (Admin)',
          from: state.currentUser.displayName,
          to: 'System (Admin)',
          amount: amount,
          newBalance: newBalance
        };
        const { receiptHTML, receiptId } = generateReceipt(successTxData, 'success');
        showReceiptModal(receiptHTML, receiptId, 'success');
        
        renderApp();
        
      } catch (error) {
        console.error('Burn error:', error);
        showNotification('Failed to burn BVN', 'error');
        
        // Generate failure receipt
        const failedTxData = {
          txId: 'FAILED_BURN_' + Date.now(),
          type: 'burn',
          from: state.currentUser.displayName,
          to: 'System (Admin)',
          amount: amount,
          error: error.message
        };
        const { receiptHTML, receiptId } = generateReceipt(failedTxData, 'failed');
        showReceiptModal(receiptHTML, receiptId, 'failed');
      }
    }

    // UI Rendering
    function renderApp() {
      const app = document.getElementById('app');

      if (!state.currentUser) {
        app.innerHTML = `
          <div class="login-screen">
            <div class="login-card">
              <h1 class="app-title">ü™ô ${state.config.app_title}</h1>
              <p class="welcome-message">${state.config.welcome_message}</p>
              <p style="font-size: 14px; opacity: 0.8; margin-bottom: 20px;">
                üí∞ Secure BVN currency system for friends
              </p>
              <button class="btn btn-primary" onclick="googleLogin()" style="width: 100%; padding: 15px; font-size: 16px;">
                üîê Sign in with Google
              </button>
            </div>
          </div>
        `;
        return;
      }

      const netWorth = state.currentUser.balance_bvn * state.currentPrice;
      const priceChange = state.priceHistory.length > 1 
        ? ((state.currentPrice - state.priceHistory[state.priceHistory.length - 2].price) / state.priceHistory[state.priceHistory.length - 2].price * 100).toFixed(2)
        : 0;

      app.innerHTML = `
        <div class="container">
          <div class="header">
            <div class="logo">
              <span>ü™ô</span>
              <span class="app-title">${state.config.app_title}</span>
            </div>
            <div class="user-info">
              ${state.currentUser.streak > 0 ? `<span class="streak-badge">üî• ${state.currentUser.streak} day streak</span>` : ''}
              <div class="avatar">${state.currentUser.avatar || 'üë§'}</div>
              <span>${state.currentUser.displayName}</span>
              <button class="btn" onclick="logout()">Logout</button>
            </div>
          </div>

          ${state.isAdmin ? `
            <div class="admin-panel">
              <h2 style="margin-bottom: 15px;">üëë Admin Control Panel</h2>
              <div class="admin-controls">
                <div class="card">
                  <h3>üí∞ Price Control</h3>
                  <div class="form-group">
                    <label for="newPrice">New BVN Price (NGN)</label>
                    <input type="number" id="newPrice" placeholder="Enter new price" value="${state.currentPrice}">
                  </div>
                  <button class="btn btn-primary" onclick="updatePriceFromInput()">Update Price</button>
                </div>
                <div class="card">
                  <h3>üè¶ Mint/Burn BVN</h3>
                  <div class="form-group">
                    <label for="mintAmount">Amount (Max 5000/day)</label>
                    <input type="number" id="mintAmount" placeholder="Enter amount">
                  </div>
                  <button class="btn btn-success" onclick="mintBVNFromInput()">Mint BVN</button>
                  <button class="btn btn-danger" onclick="burnBVNFromInput()">Burn BVN</button>
                </div>
              </div>
            </div>
          ` : ''}

          <div class="dashboard">
            <div class="card">
              <h2>üíº Your Wallet</h2>
              <div class="balance-display">${state.currentUser.balance_bvn.toFixed(4)} BVN</div>
              <p style="opacity: 0.8;">Net Worth: ‚Ç¶${netWorth.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</p>
            </div>

            <div class="card">
              <h2>üìà Current Price</h2>
              <div class="price-display">‚Ç¶${state.currentPrice.toLocaleString()}</div>
              <span class="price-change ${priceChange >= 0 ? 'price-up' : 'price-down'}">
                ${priceChange >= 0 ? '‚Üë' : '‚Üì'} ${Math.abs(priceChange)}%
              </span>
              <div class="chart-container">
                <svg class="chart-svg" id="priceChart">
                  <defs>
                    <linearGradient id="chartGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                      <stop offset="0%" style="stop-color:#4ade80;stop-opacity:0.8" />
                      <stop offset="100%" style="stop-color:#4ade80;stop-opacity:0.1" />
                    </linearGradient>
                  </defs>
                </svg>
              </div>
            </div>

            <div class="card">
              <h2>üèÜ Your Rank</h2>
              <div class="balance-display">#1</div>
              <p style="opacity: 0.8;">Top 1% of traders</p>
            </div>
          </div>

          <div class="tabs">
            <button class="tab active" onclick="switchTab('transfer')">üí∏ Transfer</button>
            <button class="tab" onclick="switchTab('leaderboard')">üèÜ Leaderboard</button>
            <button class="tab" onclick="switchTab('transactions')">üìú History</button>
            <button class="tab" onclick="switchTab('missions')">üéØ Missions</button>
          </div>

          <div id="tab-transfer" class="tab-content active">
            <div class="card">
              <h2>üí∏ Send BVN</h2>
              <form onsubmit="handleTransfer(event)">
                <div class="form-group">
                  <label for="recipientEmail">Recipient Email</label>
                  <input type="email" id="recipientEmail" placeholder="user@example.com" required>
                </div>
                <div class="form-group">
                  <label for="transferAmount">Amount (BVN)</label>
                  <input type="number" id="transferAmount" step="0.0001" placeholder="0.0000" required>
                </div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Send BVN</button>
              </form>
            </div>
          </div>

          <div id="tab-leaderboard" class="tab-content">
            <div class="card">
              <h2>üèÜ Top Holders</h2>
              <ul class="leaderboard-list" id="leaderboard-list">
                <li style="text-align: center; padding: 20px; opacity: 0.7;">Loading leaderboard...</li>
              </ul>
            </div>
          </div>

          <div id="tab-transactions" class="tab-content">
            <div class="card">
              <h2>üìú Transaction History</h2>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
                <div style="display: flex; gap: 10px; align-items: center;">
                  <select id="transactionFilter" onchange="filterTransactions()" style="
                    padding: 8px 12px;
                    border-radius: 6px;
                    border: 1px solid rgba(255, 255, 255, 0.3);
                    background: rgba(255, 255, 255, 0.1);
                    color: #ffffff;
                    font-size: 14px;
                  ">
                    <option value="all">All Transactions</option>
                    <option value="transfer">Transfers</option>
                    <option value="mint">Minted</option>
                    <option value="burn">Burned</option>
                    <option value="streak_reward">Streak Rewards</option>
                  </select>
                  <button onclick="exportTransactionHistory()" class="btn" style="padding: 8px 16px; font-size: 14px;">
                    üìä Export CSV
                  </button>
                </div>
                <div style="font-size: 14px; opacity: 0.8;">
                  Total: <span id="transactionCount">0</span> transactions
                </div>
              </div>
              <div class="transaction-list" id="transaction-list">
                <p style="text-align: center; opacity: 0.7; padding: 20px;">Loading transactions...</p>
              </div>
            </div>
          </div>

          <div id="tab-missions" class="tab-content">
            <div class="card">
              <h2>üéØ Daily Missions</h2>
              <div class="mission-card">
                <h3>üî• Login Streak</h3>
                <p>Login for 7 consecutive days to earn 0.001 BVN</p>
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${(state.currentUser.streak / 7) * 100}%"></div>
                </div>
                <p style="font-size: 12px;">${state.currentUser.streak}/7 days</p>
              </div>
              <div class="mission-card">
                <h3>üí∏ Make a Transfer</h3>
                <p>Send BVN to another user</p>
                <button class="btn btn-primary" onclick="switchTab('transfer')">Start Transfer</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Chart rendering functions
    function generatePriceHistory() {
      // Generate realistic price history for demo
      const now = Date.now();
      const history = [];
      const basePrice = state.currentPrice;
      
      for (let i = 29; i >= 0; i--) {
        const timestamp = now - (i * 24 * 60 * 60 * 1000); // 30 days back
        const variation = (Math.random() - 0.5) * 0.1; // ¬±10% variation
        const price = Math.max(100, basePrice * (1 + variation * (i / 30))); // Gradual trend
        history.push({ timestamp, price });
      }
      
      return history;
    }

    function renderPriceChart() {
      const chartSvg = document.getElementById('priceChart');
      if (!chartSvg) return;

      const history = generatePriceHistory();
      const width = 300;
      const height = 150;
      const padding = 20;

      // Clear existing content
      while (chartSvg.firstChild && chartSvg.firstChild.tagName !== 'defs') {
        chartSvg.removeChild(chartSvg.firstChild);
      }

      // Set viewBox
      chartSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);

      const prices = history.map(h => h.price);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      const priceRange = maxPrice - minPrice || 1;

      // Create grid lines
      for (let i = 0; i <= 4; i++) {
        const y = padding + (i * (height - 2 * padding)) / 4;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', padding);
        line.setAttribute('y1', y);
        line.setAttribute('x2', width - padding);
        line.setAttribute('y2', y);
        line.setAttribute('class', 'chart-grid');
        chartSvg.appendChild(line);
      }

      // Create price line
      const pathData = history.map((point, index) => {
        const x = padding + (index * (width - 2 * padding)) / (history.length - 1);
        const y = height - padding - ((point.price - minPrice) / priceRange) * (height - 2 * padding);
        return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
      }).join(' ');

      const priceLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      priceLine.setAttribute('d', pathData);
      priceLine.setAttribute('class', 'chart-line');
      chartSvg.appendChild(priceLine);

      // Create area fill
      const areaData = pathData + ` L ${width - padding} ${height - padding} L ${padding} ${height - padding} Z`;
      const priceArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      priceArea.setAttribute('d', areaData);
      priceArea.setAttribute('class', 'chart-area');
      chartSvg.appendChild(priceArea);

      // Add price labels
      const minLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      minLabel.setAttribute('x', padding);
      minLabel.setAttribute('y', height - padding + 15);
      minLabel.setAttribute('class', 'chart-label');
      minLabel.textContent = `‚Ç¶${Math.round(minPrice).toLocaleString()}`;
      chartSvg.appendChild(minLabel);

      const maxLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      maxLabel.setAttribute('x', padding);
      maxLabel.setAttribute('y', padding - 5);
      maxLabel.setAttribute('class', 'chart-label');
      maxLabel.textContent = `‚Ç¶${Math.round(maxPrice).toLocaleString()}`;
      chartSvg.appendChild(maxLabel);
    }

    // Real-time listeners
    function setupRealtimeListeners() {
      // Listen to current price
      db.collection('price_feed').doc('current').onSnapshot((doc) => {
        if (doc.exists) {
          const data = doc.data();
          state.currentPrice = data.price_ngn;
          renderApp();
          setTimeout(renderPriceChart, 100); // Render chart after DOM update
        }
      });

      // Listen to leaderboard (top users by net worth)
      db.collection('users')
        .orderBy('net_worth', 'desc')
        .limit(10)
        .onSnapshot((snapshot) => {
          const leaderboard = [];
          snapshot.forEach((doc) => {
            const userData = doc.data();
            leaderboard.push({
              uid: doc.id,
              ...userData
            });
          });
          updateLeaderboard(leaderboard);
        });

      // Listen to user's transactions
      if (state.currentUser) {
        db.collection('ledger')
          .where('from', '==', state.currentUser.uid)
          .orderBy('timestamp', 'desc')
          .limit(20)
          .onSnapshot((snapshot) => {
            const sentTransactions = [];
            snapshot.forEach((doc) => {
              sentTransactions.push({ id: doc.id, ...doc.data() });
            });

            db.collection('ledger')
              .where('to', '==', state.currentUser.uid)
              .orderBy('timestamp', 'desc')
              .limit(20)
              .onSnapshot((receivedSnapshot) => {
                const receivedTransactions = [];
                receivedSnapshot.forEach((doc) => {
                  receivedTransactions.push({ id: doc.id, ...doc.data() });
                });

                const allTransactions = [...sentTransactions, ...receivedTransactions]
                  .sort((a, b) => b.timestamp?.toDate() - a.timestamp?.toDate())
                  .slice(0, 20);

                updateTransactionHistory(allTransactions);
              });
          });
      }
    }

    function updateLeaderboard(users) {
      const leaderboardList = document.getElementById('leaderboard-list');
      if (!leaderboardList) return;

      if (users.length === 0) {
        leaderboardList.innerHTML = '<li style="text-align: center; padding: 20px; opacity: 0.7;">No users yet</li>';
        return;
      }

      leaderboardList.innerHTML = users.map((user, index) => {
        const rank = index + 1;
        const rankClass = rank <= 3 ? `rank-${rank}` : '';
        
        return `
          <li class="leaderboard-item">
            <div style="display: flex; align-items: center; gap: 15px;">
              <span class="rank ${rankClass}">${rank}</span>
              <div class="avatar">${user.avatar || 'üë§'}</div>
              <div>
                <div style="font-weight: bold;">${user.displayName}</div>
                <div style="font-size: 12px; opacity: 0.7;">${user.email}</div>
              </div>
            </div>
            <div style="text-align: right;">
              <div style="font-weight: bold;">${user.balance_bvn?.toFixed(4) || '0.0000'} BVN</div>
              <div style="font-size: 12px; opacity: 0.7;">‚Ç¶${(user.net_worth || 0).toLocaleString()}</div>
            </div>
          </li>
        `;
      }).join('');
    }

    // Store all transactions for filtering
    let allTransactions = [];
    let userCache = new Map();

    async function updateTransactionHistory(transactions) {
      const transactionList = document.getElementById('transaction-list');
      const transactionCount = document.getElementById('transactionCount');
      
      if (!transactionList) return;

      // Store all transactions globally
      allTransactions = transactions;

      if (transactions.length === 0) {
        transactionList.innerHTML = '<p style="text-align: center; opacity: 0.7; padding: 20px;">No transactions yet</p>';
        if (transactionCount) transactionCount.textContent = '0';
        return;
      }

      // Get user data for display names
      userCache.clear();
      
      for (const tx of transactions) {
        if (tx.from !== 'system' && !userCache.has(tx.from)) {
          try {
            const userDoc = await db.collection('users').doc(tx.from).get();
            if (userDoc.exists) {
              userCache.set(tx.from, userDoc.data());
            }
          } catch (error) {
            console.error('Error fetching user data:', error);
          }
        }
        if (tx.to !== 'system' && !userCache.has(tx.to)) {
          try {
            const userDoc = await db.collection('users').doc(tx.to).get();
            if (userDoc.exists) {
              userCache.set(tx.to, userDoc.data());
            }
          } catch (error) {
            console.error('Error fetching user data:', error);
          }
        }
      }

      renderTransactionList(transactions);
    }

    function renderTransactionList(transactions) {
      const transactionList = document.getElementById('transaction-list');
      const transactionCount = document.getElementById('transactionCount');
      
      if (!transactionList) return;

      if (transactionCount) {
        transactionCount.textContent = transactions.length.toString();
      }

      transactionList.innerHTML = transactions.map(tx => {
        const isSent = tx.from === state.currentUser.uid;
        const isReceived = tx.to === state.currentUser.uid;
        
        let typeLabel = tx.type.toUpperCase();
        let typeClass = 'type-receive';
        let description = '';

        if (tx.type === 'transfer') {
          if (isSent) {
            typeLabel = 'SENT';
            typeClass = 'type-send';
            const recipientData = userCache.get(tx.to);
            description = `To: ${recipientData?.displayName || 'Unknown User'}`;
          } else if (isReceived) {
            typeLabel = 'RECEIVED';
            typeClass = 'type-receive';
            const senderData = userCache.get(tx.from);
            description = `From: ${senderData?.displayName || 'Unknown User'}`;
          }
        } else if (tx.type === 'mint') {
          typeLabel = 'MINTED';
          typeClass = 'type-receive';
          description = 'Admin minted BVN';
        } else if (tx.type === 'burn') {
          typeLabel = 'BURNED';
          typeClass = 'type-send';
          description = 'Admin burned BVN';
        } else if (tx.type === 'streak_reward') {
          typeLabel = 'STREAK REWARD';
          typeClass = 'type-receive';
          description = '7-day login streak bonus';
        }

        return `
          <div class="transaction-item" data-type="${tx.type}">
            <div style="flex: 1;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <span class="transaction-type ${typeClass}">
                  ${typeLabel}
                </span>
                <button onclick="regenerateReceipt('${tx.id}', '${tx.txId}')" class="btn" style="
                  padding: 4px 8px; 
                  font-size: 12px; 
                  background: rgba(255, 255, 255, 0.1);
                  border: 1px solid rgba(255, 255, 255, 0.2);
                ">
                  üßæ Receipt
                </button>
              </div>
              <div style="font-size: 12px; opacity: 0.7;">
                ${description}
              </div>
              <div style="font-size: 11px; opacity: 0.6; margin-top: 2px;">
                ID: ${tx.txId || 'N/A'}
              </div>
            </div>
            <div style="text-align: right; margin-left: 15px;">
              <div style="font-weight: bold; font-size: 16px;">${tx.amount} BVN</div>
              <div style="font-size: 12px; opacity: 0.7;">
                ‚Ç¶${(tx.amount * state.currentPrice).toLocaleString()}
              </div>
              <div style="font-size: 11px; opacity: 0.6;">
                ${tx.timestamp ? tx.timestamp.toDate().toLocaleDateString() + ' ' + tx.timestamp.toDate().toLocaleTimeString() : 'Unknown date'}
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Transaction filtering
    window.filterTransactions = function() {
      const filter = document.getElementById('transactionFilter').value;
      
      let filteredTransactions = allTransactions;
      
      if (filter !== 'all') {
        filteredTransactions = allTransactions.filter(tx => tx.type === filter);
      }
      
      renderTransactionList(filteredTransactions);
    };

    // Export transaction history to CSV
    window.exportTransactionHistory = function() {
      if (allTransactions.length === 0) {
        showNotification('No transactions to export', 'error');
        return;
      }

      const csvHeaders = [
        'Date',
        'Time',
        'Transaction ID',
        'Type',
        'From',
        'To',
        'Amount (BVN)',
        'Value (NGN)',
        'Status'
      ];

      const csvRows = allTransactions.map(tx => {
        const date = tx.timestamp ? tx.timestamp.toDate() : new Date();
        const isSent = tx.from === state.currentUser.uid;
        const isReceived = tx.to === state.currentUser.uid;
        
        let fromName = 'System';
        let toName = 'System';
        
        if (tx.from !== 'system') {
          const fromData = userCache.get(tx.from);
          fromName = fromData?.displayName || 'Unknown User';
        }
        
        if (tx.to !== 'system') {
          const toData = userCache.get(tx.to);
          toName = toData?.displayName || 'Unknown User';
        }

        return [
          date.toLocaleDateString(),
          date.toLocaleTimeString(),
          tx.txId || 'N/A',
          tx.type.toUpperCase(),
          fromName,
          toName,
          tx.amount,
          (tx.amount * state.currentPrice).toFixed(2),
          'Completed'
        ];
      });

      const csvContent = [csvHeaders, ...csvRows]
        .map(row => row.map(field => `"${field}"`).join(','))
        .join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Bitven_Transaction_History_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showNotification('Transaction history exported successfully!', 'success');
    };

    // Regenerate receipt for existing transaction
    window.regenerateReceipt = async function(transactionDocId, txId) {
      const transaction = allTransactions.find(tx => tx.id === transactionDocId || tx.txId === txId);
      
      if (!transaction) {
        showNotification('Transaction not found', 'error');
        return;
      }

      const isSent = transaction.from === state.currentUser.uid;
      const isReceived = transaction.to === state.currentUser.uid;
      
      let fromName = 'System';
      let toName = 'System';
      
      if (transaction.from !== 'system') {
        const fromData = userCache.get(transaction.from);
        fromName = fromData?.displayName || 'Unknown User';
      }
      
      if (transaction.to !== 'system') {
        const toData = userCache.get(transaction.to);
        toName = toData?.displayName || 'Unknown User';
      }

      const receiptData = {
        txId: transaction.txId,
        type: transaction.type,
        fromName: fromName,
        toName: toName,
        from: fromName,
        to: toName,
        amount: transaction.amount,
        newBalance: transaction.balancesAfter?.[state.currentUser.uid] || state.currentUser.balance_bvn
      };

      const { receiptHTML, receiptId } = generateReceipt(receiptData, 'success');
      showReceiptModal(receiptHTML, receiptId, 'success');
    };

    // Auth state listener
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        // User is signed in
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (userDoc.exists) {
          const userData = userDoc.data();
          state.currentUser = {
            uid: user.uid,
            ...userData
          };
          state.isAdmin = userData.role === 'admin';
          
          // Get current price
          const priceDoc = await db.collection('price_feed').doc('current').get();
          if (priceDoc.exists) {
            state.currentPrice = priceDoc.data().price_ngn;
          }
          
          setupRealtimeListeners();
          renderApp();
          setTimeout(renderPriceChart, 100); // Render chart after DOM update
        }
      } else {
        // User is signed out
        state.currentUser = null;
        state.isAdmin = false;
        renderApp();
      }
    });

    // Event Handlers
    window.googleLogin = googleLogin;
    window.logout = logout;
    
    window.switchTab = function(tabName) {
      document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      
      event.target.classList.add('active');
      document.getElementById(`tab-${tabName}`).classList.add('active');
    };

    window.handleTransfer = async function(event) {
      event.preventDefault();
      const recipientEmail = document.getElementById('recipientEmail').value;
      const amount = document.getElementById('transferAmount').value;
      await transferBVN(recipientEmail, amount);
      event.target.reset();
    };

    window.updatePriceFromInput = function() {
      const newPrice = parseFloat(document.getElementById('newPrice').value);
      if (newPrice > 0) {
        updatePrice(newPrice);
      }
    };

    window.mintBVNFromInput = function() {
      const amount = parseFloat(document.getElementById('mintAmount').value);
      if (amount > 0) {
        mintBVN(amount);
        document.getElementById('mintAmount').value = '';
      }
    };

    window.burnBVNFromInput = function() {
      const amount = parseFloat(document.getElementById('mintAmount').value);
      if (amount > 0) {
        burnBVN(amount);
        document.getElementById('mintAmount').value = '';
      }
    };

    // Notification System
    function showNotification(message, type = 'success') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      document.body.appendChild(notification);

      setTimeout(() => {
        notification.remove();
      }, 3000);
    }

    window.showNotification = showNotification;

    // Initialize
    async function init() {
      const initResult = await window.dataSdk.init(dataHandler);
      if (!initResult.isOk) {
        console.error('Failed to initialize Data SDK');
      }

      await window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities: (config) => ({
          recolorables: [
            {
              get: () => config.primary_color || defaultConfig.primary_color,
              set: (value) => {
                config.primary_color = value;
                window.elementSdk.setConfig({ primary_color: value });
              }
            },
            {
              get: () => config.secondary_color || defaultConfig.secondary_color,
              set: (value) => {
                config.secondary_color = value;
                window.elementSdk.setConfig({ secondary_color: value });
              }
            },
            {
              get: () => config.text_color || defaultConfig.text_color,
              set: (value) => {
                config.text_color = value;
                window.elementSdk.setConfig({ text_color: value });
              }
            },
            {
              get: () => config.surface_color || defaultConfig.surface_color,
              set: (value) => {
                config.surface_color = value;
                window.elementSdk.setConfig({ surface_color: value });
              }
            },
            {
              get: () => config.accent_color || defaultConfig.accent_color,
              set: (value) => {
                config.accent_color = value;
                window.elementSdk.setConfig({ accent_color: value });
              }
            }
          ],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map([
          ['app_title', config.app_title || defaultConfig.app_title],
          ['welcome_message', config.welcome_message || defaultConfig.welcome_message]
        ])
      });

      // Initialize default price if not set
      try {
        const priceDoc = await db.collection('price_feed').doc('current').get();
        if (!priceDoc.exists) {
          await db.collection('price_feed').doc('current').set({
            price_ngn: 1500,
            updatedBy: 'system',
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
          });
          state.currentPrice = 1500;
        }
      } catch (error) {
        console.error('Error initializing price:', error);
        state.currentPrice = 1500;
      }

      renderApp();
    }

    init();
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'99b6ade9c0a9218d',t:'MTc2MjYyMTc3OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
